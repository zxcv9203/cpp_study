# C++ 참조자(레퍼런스)의 도입

> 참조자의 도입

``` c++
#include <iostream>

int change_val(int *p) {
	*p = 3;
	return (0);
}

int main() {
	int number = 5;

	std::cout << number << std::endl;
	change_val(&number);
	std::cout << number << std::endl;
}
```

위 코드를 성공적으로 컴파일하고 실행시켰다면
```
5
3
```
와 같이 나옵니다.

change_val 함수의 인자 p에 number의 주소값을 전달하여, *p를 통해 number를 참조하여 number의 값을 3으로 바꾸었습니다.

C언어에서는 어떠한 변수를 가리키고 싶을 땐 반드시 포인터를 사용해야 만 했습니다.

그런데 C++에서는 다른 변수나 상수를 가리키는 방법으로 또 다른 방식을 제공하는데, 이를 바로 참조자(reference)라고 부릅니다.

``` c++
#include <iostream>

int main() {
	int a = 3;
	int &another_a = a;

	another_a = 5;
	std::cout << "a : " << a << std::endl;
	std::cout << "another_a : " << another_a << std::endl;

	return 0;
}
```

성공적으로 컴파일 하였다면
```
a : 5
another_a : 5
```
와 같이 나옵니다.

먼저 우리는 다음과 같이 간단히 `int` 형 변수인 `a`를 정의하였고 그 안에 3이란 값을 넣어주었습니다.

```
int a = 3;
```

그 후에 우리는 `a`의 참조자 `another_a`를 정의하였습니다. 이 때 참조자를 정하는 방법은, 가리키고자 하는 타입 뒤에서 `&`을 붙이면됩니다.

위 처럼 int형 변수의 참조자를 만들고 싶을 때에는 `int&`를, `double`의 참조자를 만드려면 `double&` 로 하면됩니다.

심지어 `int*` 와 같은 포인터 타입의 참조자를 만드려면 `int*&`로 쓰면 됩니다.

위와 같이 선언함으로서 우리는 `another_a`는 `a`의 참조자다! 라고 공표하게 되었습니다.

이 말은 즉슨 `another_a`는 `a`의 또다른 이름이라고 컴파일러에게 알려주는 것입니다.

따라서 another_a에 어떠한 작업을 수행하든 이는 사실상 `a`에 그 작업을 하는 것과 마찬가지 입니다.

```c++
another_a = 5;
std::cout << "a : " << a << std::endl; 
```

따라서 위 처럼 `another_a`에 5를 대입하였지만 실제로 `a`의 값을 확인해보면 5로 바뀌었음을 확인할 수 있습니다.

어떻게 보면 참조자와 포인터는 상당히 유사한 개념입니다.

포인터 역시 다른 어떤 변수의 주소값을 보관함으로써 해당 변수에 간접적으로 연산을 수행할 수 있기 때문이죠.

하지만 레퍼런스와 포인터는 몇 가지 중요한 차이점이 있습니다.

1. 레퍼런스(참조자)는 반드시 처음에 누구의 별명이 될 것인지 지정해야 합니다.

레퍼런스는 정의 시에 반드시 누구의 별명인지 명시해야 합니다.

```c++
int &another_a;
```
위와 같은 문장은 불가능합니다.

포인터의 경우
``` c++
int *p;
```
는 전혀 문제가 없는 코드입니다.

2. 레퍼런스가 한 번 별명이 되면 절대로 다른 이의 별명이 될 수 없습니다.

레퍼런스의 또 한가지 중요한 특징으로 한 번 어떤 변수의 참조가 되버린다면, 이 더이상 다른 변수를 참조할 수 없게됩니다.

예를 들어서 다음과 같은 코드를 살펴봅시다.

``` c++
int a = 10;
int &another_a = a;

int b = 3;
another_a = b;
```

마지막에 another_a = b 문장은 어떤 의미일까요? another_a를 보고 다른 변수인 b를 가리키라고 하는 것일까요?

아닙니다! 이는 그냥 a에 b의 값을 대입하라는 의미입니다. 앞서 말했듯이 another_a 무언가를 하는 것은 사실상 a에 무언가를 하는 것과 동일하다고 했으므로 이 문장은 그냥 a = b와 동일합니다.

그렇다면 다음 코드는 어떨까요?

``` c++
&another_a = b;
```

위문장은 그냥 &a = b가 되어서 말이안되는 문장이 됩니다.

반면에 포인터는 어떨까요

``` c++
int a = 10;
int *p = &a; // p는 a를 가리킵니다.

int b = 3;
p = &b; // 이제 p는 a를 버리고 b를 가리킵니다.
```

위와 같이 누구를 가리키는지 자유롭게 바뀔 수 있습니다.

3. 레퍼런스는 메모리 상에 존재하지 않을 수도 있습니다.

포인터의 경우를 생각해봅시다.

우리가 아래와 같이 포인터 p를 정의한다면

``` c++
int a = 10;
int *p = &a;
```

p는 당당히 메모리 상에서 8바이트를 차지하는 녀석이 됩니다. (물론 32비트 시스템에서는 4바이트 입니다.)

그런데 레퍼런스의 경우를 생각해봅시다.

``` c++
int a = 10
int &another_a = a;
```

만일 내가 컴파일러라면 another_a를 위해서 메모리 상에 공간을 할당할 필요가 있을까요?

아니죠! 왜냐하면 another_a가 쓰이는 자리는 모두 a로 바꿔치기 하면 되니까요.

따라서 이 경우 레퍼런스는 메모리 상에 존재하지 않게 됩니다.

물론 그렇다고 해서 항상 존재하지 않는 것은 아닙니다.

> 함수 인자로 레퍼런스 받기

```c++
#include <iostream>

int change_val(int &p) {
	p = 3;

	return 0;
}

int main() {
	int number = 5;

	std::cout << number << std::endl;
	change_val(number);
	std::cout << number << std::endl;
}
```

성공적으로 컴파일 하였다면 다음과 같이 나올 것입니다.

```
5
3
```

위 코드는 앞서 포인터를 사용해서 number를 change_val 안에 전달한 코드를 참조자를 이용해서 바꿔본 것입니다.

먼저 가장 중요한 부분으로 함수의 인자로 참조자를 받게 하였습니다.

```
int change_val(int &p)
```
근데 아까 int &p와 같이 단순히 선언만 하는 것은 불가능하다고 하였습니다.

하지만 위의 경우는 p가 선언되는 순간은 `change_val(number)`를 호출할때 이므로 사실상 `int &p = number`가 실행된다고 생각하면 됩니다.

따라서 아무 문제가 없습니다.

아무튼 위와 같이 참조자 p에게 너는 앞으로 number의 새로운 별명이야라고 알려주게 됩니다.

```c++
change_val(number);
```
여기서 중요한 점은 포인터가 인자일 때와는 다르게 number 앞에 &을 붙일 필요가 없다는 점입니다.

이는 참조자를 정의할 때 그냥 int &a = b와 같이 한 것과 일맥상통합니다.

``` c++
int change_val(int &p) {
	p = 3;
	return 0;
}

그 후 change_val 안에서 p = 3이라 하는 것은 main 함수의 number에 number = 3을 하는 것과 정확히 같은 작업입니다.

```

> 여러가지 참조자 예시들

``` c++
#include <iostream>

int main() {
	int x;
	int &y = x;
	int &z = y;
	
	x = 1;
	std::cout << "x : " << x << " y : " << y << " z : " << z << std::endl;

	y = 2;
	std::cout << "x : " << x << " y : " << y << " z : " << z << std::endl;
	
	z = 3;
	std::cout << "x : " << x << " y : " << y << " z : " << z << std::endl;
}
```

성공적으로 컴파일하여 실행한다면 다음과 같은 결과가 나올 것입니다.

``` c++
x : 1 y : 1 z : 1
x : 2 y : 2 z : 2
x : 3 y : 3 z : 3
```

예상하고 계셨던 결과 인가요?

``` c++
int x;
int &y = x;
```

먼저 위와 같이 x의 참조자로 y를 정의하였습니다.

이제 y는 x의 또다른 별명이 됩니다.

``` c++
int &z = y;
```

그렇다면 다음 문장을 봅시다. 간혹 아래와 같이 고개를 갸우뚱할 수 도 있습니다.

아까 어떤 타입 t의 참조자 타입은 t& 라고 했는데, 여기서 y가 int& 니까 z의 참조자 타입은 int&&이 되야하지 않을까요?

좋은 질문입니다.

하지만 참조자의 참조자라는 말의 의미를 생각해보면 사실 말이 안된다는 것을 알 수 있습니다.

굳이 별명의 별명을 만들 필요는 없으니까요!

실제로 C++ 문법 상 참조자의 참조자를 만드는 것은 금지되어 있습니다.

```c++
int &z = y;
```

즉, 위 문장은 결국 x의 참조자를 선언해라와 같은 의미가 되서, z 역시 x의 참조자가 될 것입니다.

따라서 y와 z 모두 x의 참조자가 됩니다.

처음에 참조자를 접하는 분들은 왜 굳이 포인터로 할 수 있는 것을 참조자로 해야하냐고 물을 수 있습니다.

하지만 참조자를 사용하게 되면 불필요한 &과 *가 필요 없기 때문에 코드를 훨씬 간결하게 나타낼 수 있습니다.

예를 들어서 지난 강좌에서 변수 입력시 배웠던 cin을 기억하시나요?

아마 사용자로 부터 변수에 값을 입력 받을 때 다음과 같이 했었을 것입니다.

``` c++
std::cin >> user;
```

그런데 무언가 이상하지 않으신가요? 예전에 scanf로 이용할 때는 분명히 다음과 같이 주소 값을 전달해 주었었습니다.

``` c++
scanf("%d", &user)
```

왜냐하면 어떤 변수의 값을 다른 함수에서 변경하기 위해서는 항상 포인터로 주소 값을 전달해야하기 때문이니까요

하지만 여기서 cin이라는 것에 그냥 user를 전달했는데 잘 작동합니다.

왜 그럴까요? 바로 cin이 바로 레퍼런스로 user를 받아서 그렇습니다.

따라서 불필요하게 &을 user앞에 붙일 필요가 없게 되는 것입니다.

>> 상수에 대한 참조자

``` c++
#include <iostream>

int main() {
	int &ref = 4;

	std::cout << ref << std::endl;
}
```

위와 같은 소스를 살펴봅시다.

일단 컴파일을 하면 다음과 같은 오류가 발생할 것입니다.

```
const_ref.cpp:4:7: error: non-const lvalue reference to type 'int' cannot bind to a temporary of type 'int'
```

왜 오류가 날까요?

아마 여러분들은 다 알고 계시겠지요 위 상수 값 자체는 리터럴이기 때문에 만일 위와 같이 레퍼런스로 참조한다면 

``` c++
ref = 5
```
로 리터럴 자체의 값을 바꾸는 말도 안되는 행위가 가능하게 됩니다.

따라서 C++ 문법 상 상수 리터럴을 일반적인 레퍼런스가 참조하는 것은 불가능하게 되어 있습니다.

물론 그 대신에 다음과 같이 상수 참조자로 선언한다면 리터럴도 참조할 수 있습니다.

``` c++
const int &ref = 4;
```

``` c++
int a = ref;
```

위와 같이 사용하면 a = 4 와 동일하게 처리됩니다.

> 레퍼런스의 배열과 배열의 레퍼런스

먼저 레퍼런스의 배열이 과연 가능한 것인지에 대해 부터 생각해봅시다.

앞서 말했듯이 레퍼런스는 반드시 정의와 함께 초기화를 해주어야 한다고 했습니다.

따라서 여러분의 머릿속에는 다음과 같이 레퍼런스의 배열을 정의하는 것을 떠올렸을 것입니다.

``` c++
int a, b;
int &arr[2] = {a, b}
```

컴파일을 해보면 다음과 같은 오류가 발생할 것입니다.

```
arr_ref.cpp:3:10: error: 'arr' declared as array of references of type 'int &'
```

참조자는 배열로 선언될 수 없다는 메시지가 나옵니다.

그러면 도대체 왜 안될까요?

``` cpp
int &arr[2] = {a, b};
```

arr[0]은 a를 의미하고 arr[1]은 b를 의미하고..로 만들면 안될까요?

이와 같은 주장을 하기 전에 C++ 상에서 배열이 어떤 식으로 처리되는지 생각해봅시다.

문법 상 배열의 이름은 (`arr`) 첫 번째 원소의 주소 값으로 변환이 될 수 있어야 합니다.

이 때문에 arr[1]과 같은 문장이 *(arr + 1)로 바뀌어서 처리될 수 있기 때문이죠

그런데 주소 값이 존재한다라는 의미는 해당 원소가 메모리 상에서 존재한다라는 의미와 같습니다.

하지만 레퍼런스는 특별한 경우가 아닌 이상 메모리 상에서 공간을 차지하지 않습니다.

따라서 이러한 모순 때문에 레퍼런스들의 배열을 정의하는 것은 언어 차원에서 금지가 되어 있는 것입니다.

그렇다고 해서 그와 반대인 배열들의 레퍼런스가 불가능한 것은 아닙니다.

``` c++
231
```

먼저 가장 중요한 첫 두줄을 살펴봅시다.

``` c++
int arr[3] = {1, 2, 3};
int (&ref)[3] = arr;
```

위와 같이 ref가 arr을 참조하도록 하였습니다.

따라서 ref[0] 부터 ref[2]가 각각 arr[0]부터 arr[2]의 레퍼런스가 됩니다.

포인터와는 다르게 배열의 레퍼런스의 경우 참조하기 위해서 반드시 배열의 크기를 명시해야 합니다.

따라서 int (&ref)[3] 이라면 반드시 크기가 3인 int 배열의 별명이 되어야 하고 int (&ref)[5]라면 크기가 5인 int 배열의 별명이 되어야 합니다.

2차원 배열 역시 일차원 배열과 동일합니다.

```c++
int arr[3][2] = {1, 2, 3, 4, 5, 6};
int (&ref)[3][2] = arr;
```

> 레퍼런스를 리턴하는 함수

먼저 아래 코드를 살펴봅시다.

``` c++
int function() {
	int a = 2;
	return a;
}

int b = function();
return 0;
```

아마 여기 까지 따라 오신 분들이라면 무리 없이 이해할 수 있겠죠. 제가 주목하고 싶은 부분은 바로 이 부분입니다.

``` c++
int b = function();
```

여기서 무슨 일이 일어났을까요?

이미 잘 아시겠지만 function 안에 정의된 a라는 변수의 값이 b에 복사되었습니다.

여기서 주목할 점은 복사 되었다는 점입니다.

function이 종료되고 나면 a는 메모리에서 사라지게 됩니다.

따라서 더 이상 main 안에서는 a를 만날 길이 없습니다.

- 지역 변수의 레퍼런스를 리턴?

그 다음 예시를 살펴봅시다.

```cpp
#include <iostream>

int &function() {
	int a = 2;
	return a;
}

int main(void)
{
	int b = function();
	b = 3;
	std::cout << b << std::endl;
	return 0;	
}
```

컴파일을 하면 다음과 같은 경고가 발생합니다.

```
ref_func.cpp:5:9: warning: reference to stack memory associated with local variable 'a' returned [-Wreturn-stack-address]
```

실행하면 결과는 잘 출력되지만 왜 경고가 발생할까요?

``` cpp
int &function() {
	int a = 2;
	return a;
}
```

function의 리턴 타입은 int& 입니다.

따라서 참조자를 리턴하게 됩니다.

그런데 문제는 리턴하는 `function` 정의되어있는 a는 함수의 리턴과 함께 사라진다는 점입니다.

```
int b = function();
```

위 문장은 사실상

``` cpp
int &ref = a;
// a가 사라짐
int b = ref; // ?
```
와 같은 의미인데 function이 레퍼런스를 리턴하면서 원래 참조하고 있던 변수가 이미 사라져 버렸으므로 오류가 발생하게 됩니다.

쉽게 말해 본체는 이미 사라졌지만 별명만 남아 있는 상황입니다.

이와 같이 레퍼런스는 있는데 원래 참조하던 것이 사라진 레퍼런스를 댕글링 레퍼런스라고 부릅니다.

Dangling이란 단어의 원래 뜻은 약하게 결합되서 달랑달랑 거리는 것을 뜻하는데, 레퍼런스가 참조해야할 변수가 사라져서 혼자서 덩그러니 남아있는 상황과 유사하다고 보시면 됩니다.

```
🚨 따라서 위처럼 레퍼런스를 리턴하는 함수에서 지역변수의 레퍼런스를 리턴하지 않도록 조심해야 합니다.
```

- 외부 변수의 레퍼런스를 리턴

그렇다면 이 경우는 어떨까요?

``` cpp
int &function(int &a) {
	a = 5;
	return a;
}

int main() {
	int b = 2;
	int c = function(b);
	return 0;
}
```

이 function 역시 레퍼런스를 리턴하고 있습니다.

하지만 아까와의 차이점은

``` cpp
int &function(int &a) {
	a = 5;
	return a;
}
```

위와 같이 인자로 받는 레퍼런스를 그대로 리턴하고 있습니다.

function(b)를 실행한 시점에서 a는 main의 b를 참조하고 있게 됩니다.

따라서 function이 리턴한 참조자는 아직 살아있는 변수인 b를 계속 참조합니다.

결국 위 문장은 다음과 같습니다.

``` cpp
int c = function(b);
```

c에 b의 현재값(5)를 대입하는 것과 동일한 문장이 됩니다.

그렇다면 이렇게 참조자를 리턴하는 경우 장점이 무엇일까요?

C언어에서 엄청나게 큰 구조체가 있을 때 해당 구조체 변수를 그냥 리턴하면 전체 복사가 발생해야 해서 시간이 오래 걸리지만, 해당 구조체를 가리키는 포인터를 리턴한다면 그냥 포인터 주소 한 번 복사로 매우 빠르게 끝납니다.

마찬가지로 레퍼런스를 리턴하게 된다면 레퍼런스가 참조하는 타입의 크기와 상관 없이 딱 한 번의 주소 값 복사로 전달이 끝나게 됩니다.

따라서 매우 효율적이죠!

- 참조가 아닌 값을 리턴하는 함수를 참조자로 받기

이번에는 반대로 함수가 값을 리턴하는데 참조자로 받는 경우를 생각해 봅시다.

``` cpp
int function() {
	int a = 5;
	return a;
}

int main() {
	int &c = function();
	return 0;
}
```

컴파일 하였다면 아래와 같은 오류가 발생합니다.

```
ref_func.cpp:10:7: error: non-const lvalue reference to type 'int' cannot bind to a temporary of type 'int'
```

컴파일 오류를 읽어보면 상수가 아닌 레퍼런스가 function 함수의 리턴 값을 참조할 수 없다는 의미가 되겠습니다.

```
컴파일 메시지를 자세히 보면 lvalue, rvalue 이야기가 나오는데, 나중 강좌에서 lvalue나 rvalue가 뭔지 자세히 다루겠습니다.
```

```cpp
int &c = function();
```

왜 c는 function의 리턴 값을 참조할 수 없는 것일까요?

이는 아까전 상황과 마찬가지로 함수의 리턴 값은 해당 문장이 끝난 후 바로 사라지는 값이기 때문에 참조자를 만들게 됨녀 바로 다음에 댕글링 레퍼런스가 되어버리기 때문입니다.

하지만 C++에서 중요한 예외 규칙이 있습니다.

다음 코드를 실행시켜봅시다.

``` cpp
#include <iostream>

int function() {
	int a = 5;
	return a;
}

int main() {
	const int &c = function();
	std::cout << "c : " << c << std::endl;
	return 0;
}
```

function()의 리턴 값을 참조자를 받았음에도, const 참조자로 받았더니 에러가 발생하지 않고 출력이 잘되는 것을 볼 수 있습니다.

원칙상 함수의 리턴 값은 해당 문장이 끝나면 소멸되는 것이 정상입니다.

따라서 기존에 int&로 받았을 때에는 컴파일 자체가 안되었습니다.

하지만 예외적으로 상수 레퍼런스로 리턴값을 받게되면 해당 리턴값의 생명이 연장됩니다.

그리고 연장되는 기간은 레퍼런스가 사라질 때 까지입니다.

지금까지 배운 것을 정리하면 다음과 같습니다.

|                                  | 함수에서 값 리턴(int f()) | 함수에서 참조자 리턴(int &f()) |
|----------------------------------|--------------------------|------------------------------|
|값 타입으로 받음 `int a = f()`              | 값 복사됨        | 값 복사됨. 다만 지역 변수의 레퍼런스를 리턴하지 않도록 주의
|참조자 타입으로 받음 `int &a = f()`          | 컴파일 오류      |가능. 마찬가지로 지역변수의 레퍼런스를 리턴하지 않도록 주의
|상수 참조자 타입으로 받음 `const int& a= f()`| 가능             | 가능. 마찬가지로 지역변수의 레퍼런스를 리턴하지 않도록 주의


